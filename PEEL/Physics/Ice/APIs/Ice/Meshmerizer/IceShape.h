///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Contains code for shapes.
 *	\file		IceShape.h
 *	\author		Pierre Terdiman
 *	\date		September, 17, 2000
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Include Guard
#ifndef ICESHAPE_H
#define ICESHAPE_H

	class MESHMERIZER_API Curve : public VertexCloud, public Allocateable
	{
		public:
		//! Constructor
								Curve() : mClosed(false)	{}
		//! Destructor
		virtual					~Curve()					{}

		inline_	udword			GetNbSegments()	const
								{
									udword NbSegments = GetNbVerts() - 1;
									if(mClosed)	NbSegments++;
									return NbSegments;
								}

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		*	Gets a point on the curve.
		*	\param		p		[out] returned point
		*	\param		seg		[in] segment index
		*	\param		t		[in] position on segment (0.0f => 1.0f)
		*	\return		true if success
		*/
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				bool			GetPoint(Point& p, udword seg, float t)	const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		*	Gets a point on the curve.
		*	\param		p			[out] returned point
		*	\param		t			[in] position on curve (0.0f => 1.0f)
		*	\param		segment_pts	[out] returns segment points in segment_pts[0] and segment_pts[1]
		*	\return		true if success
		*/
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				bool			GetPoint(Point& p, float t, Point* segment_pts=null)	const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		*	Computes curve length.
		*	\return		length of curve
		*/
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				float			ComputeLength()	const;

				bool			mClosed;	//!< Curve's closure
	};

	class MESHMERIZER_API Shape// : public Allocateable
	{
		public:
								Shape();
		virtual					~Shape();
		// Settings

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Setups number of curves.
		 *	\param		nbcurves	[in] number of curves in the shape
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				bool			SetNbCurves(udword nbcurves);

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Setups a given curve.
		 *	\param		id			[in] curve index
		 *	\param		nb_verts	[in] number of vertices in the curve
		 *	\param		verts		[in] curve's vertices
		 *	\param		closed		[in] closure
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				bool			SetCurve(udword id, udword nb_verts, const Point* verts, bool closed);

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the total number of vertices in the shape.
		 *	\return		total number of vertices in all curves
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				udword			GetTotalNbVerts()			const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the shape's AABB.
		 *	\param		aabb	[out] the shape's bounding box
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				void			ComputeAABB(AABB& aabb)		const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Gets a point on the shape.
		 *	\param		p		[out] returned point
		 *	\param		curve	[in] curve index
		 *	\param		seg		[in] segment index
		 *	\param		t		[in] position on segment (0.0f => 1.0f)
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline_	bool			GetPoint(Point& p, udword curve, udword seg, float t) const
								{
									if(!mCurves || curve>=mNbCurves)
										return false;
									return mCurves[curve].GetPoint(p, seg, t);
								}

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Gets a point on the shape.
		 *	\param		p		[out] returned point
		 *	\param		curve	[in] curve index
		 *	\param		t		[in] position on curve (0.0f => 1.0f)
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline_	bool			GetPoint(Point& p, udword curve, float t) const
								{
									if(!mCurves || curve>=mNbCurves)
										return false;
									return mCurves[curve].GetPoint(p, t);
								}

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Gets a random point on the shape.
		 *	\param		p		[out] returned point
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				bool			GetRandomPt(Point& p)		const;

		// Data access
		inline_	udword			GetNbCurves()				const	{ return mNbCurves;		}
		inline_	const Curve*	GetCurve(udword i)			const	{ return &mCurves[i];	}

		protected:
				udword			mNbCurves;		//!< Number of curves in the shape
				Curve*			mCurves;		//!< Array of curves
	};

#endif // ICESHAPE_H
