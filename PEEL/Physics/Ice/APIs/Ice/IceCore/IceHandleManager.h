///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Contains a handle manager.
 *	\file		IceHandleManager.h
 *	\author		Pierre Terdiman
 *	\date		December, 12, 1999
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Include Guard
#ifndef ICEHANDLEMANAGER_H
#define ICEHANDLEMANAGER_H

//	#include "IceHandleManagerDef.h"
//	#include "IceHandleManagerTemplateDef.h"

//#ifdef OLDIES
    typedef udword  Handle;

	class ICECORE_API HandleManager : public Allocateable
	{
		public:
							HandleManager();
							~HandleManager();
		// Basic usage
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Adds an object to the manager.
		 *	\param		object	[in] the new object to be added.
		 *	\return		The object's handle. Use it as further reference for the remove method.
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				Handle		Add(void* object);

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Removes an object from the manager.
		 *	\param		handle	[in] the handle returned from the Add() method.
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				void		Remove(Handle handle);

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Gets an object from the list. Returns real pointer according to handle.
		 *	\param		handle	[in] the handle returned from the Add() method.
		 *	\return		the corresponding object
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				void*		GetObject(Handle handle)	const;	// Returns object according to handle.

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Updates an object.
		 *	\param		handle	[in] the handle returned from the Add() method.
		 *	\param		object	[in] the object's new address
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				bool		UpdateObject(Handle handle, void* object);

		// Advanced usage
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Remaps the inner array in an app-friendly order. Of course all handles remain valid.
		 *	\param		ranks	[in] remapping table => ranks[i] = index of new object i in old list
		 *	\return		true if success
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				bool		Remap(const udword* ranks);

		// Physical data access
		inline_	udword		GetMaxNbObjects()			const	{ return mMaxNbObjects;		}	//!< Returns max number of objects
		inline_	udword		GetNbObjects()				const	{ return mCurrentNbObjects;	}	//!< Returns current number of objects
		inline_	void**		GetObjects()				const	{ return mObjects;			}	//!< Gets the complete list of objects

		//! High-speed access - same as GetObject without any checkings - handle with care.
		inline_	void*		PickObject(Handle handle)	const	{ return mObjects[mOutToIn[uword(handle)]]; }

		// Stats
				udword		GetUsedRam()				const;

							PREVENT_COPY(HandleManager)
		private:
		// Physical list
				void**		mObjects;			//!< Physical list, with no holes but unsorted.
				udword		mCurrentNbObjects;	//!< Current number of objects in the physical list.
				udword		mMaxNbObjects;		//!< Maximum possible number of objects in the physical list.

		// Cross-references
				uword*		mOutToIn;			//!< Maps virtual indices (handles) to real ones.
				uword*		mInToOut;			//!< Maps real indices to virtual ones (handles).
                uword*      mStamps;

		// Recycled locations
				udword		mNbFreeIndices;		//!< Current number of free indices

		// Internal methods
				bool		SetupLists(void** objects=null, uword* oti=null, uword* ito=null, uword* stamps=null);
	};
//#endif

#endif //ICEHANDLEMANAGER_H
