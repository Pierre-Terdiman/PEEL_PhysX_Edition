///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Contains a handy indexed triangle class.
 *	\file		IceIndexedTriangle.h
 *	\author		Pierre Terdiman
 *	\date		January, 17, 2000
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Include Guard
#ifndef ICEINDEXEDTRIANGLE_H
#define ICEINDEXEDTRIANGLE_H

	// Forward declarations
	enum CubeIndex;

	//! Computes a point on a triangle using barycentric coordinates. (It's only been extracted as a function
	//! so that there's no confusion regarding the order in which u and v should be used)
	inline_ void ComputeBarycentricPoint(Point& pt, const Point& p0, const Point& p1, const Point& p2, float u, float v)
	{
		// The compiler doesn't like this version much and tends not to inline all operators
		//pt = (1.0f - u - v)*p0 + u*p1 + v*p2;
		const float w = 1.0f - u - v;
		pt.x = w*p0.x + u*p1.x + v*p2.x;
		pt.y = w*p0.y + u*p1.y + v*p2.y;
		pt.z = w*p0.z + u*p1.z + v*p2.z;
	}

	// An indexed triangle class.
	class ICEMATHS_API IndexedTriangle : public Allocateable
	{
		public:
		//! Constructor
		inline_					IndexedTriangle()									{}
		//! Constructor
		inline_					IndexedTriangle(udword r0, udword r1, udword r2)	{ mRef[0]=r0; mRef[1]=r1; mRef[2]=r2; }
		//! Copy constructor
		inline_					IndexedTriangle(const IndexedTriangle& triangle)
								{
									mRef[0] = triangle.mRef[0];
									mRef[1] = triangle.mRef[1];
									mRef[2] = triangle.mRef[2];
								}
		//! Destructor
		inline_					~IndexedTriangle()									{}
		//! Indices of referenced objects.
		//! Design note: this used to be "mVRef" for "vertex reference", but we now use the same
		//! class to index different things (e.g. edges). So the more general "mRef" name is used.
				udword			mRef[3];

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Flips the winding order.
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline_	void			Flip()
								{
									Swap(mRef[1], mRef[2]);
								}

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the triangle area.
		 *	\param		verts	[in] the list of indexed vertices
		 *	\return		the area
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				float			Area(const Point* verts)											const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the triangle perimeter.
		 *	\param		verts	[in] the list of indexed vertices
		 *	\return		the perimeter
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				float			Perimeter(const Point* verts)										const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the triangle compacity.
		 *	\param		verts	[in] the list of indexed vertices
		 *	\return		the compacity
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				float			Compacity(const Point* verts)										const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the triangle normal.
		 *	\param		verts	[in] the list of indexed vertices
		 *	\param		normal	[out] the computed normal
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline_	void			Normal(const Point* verts, Point& normal)							const
								{
									if(!verts)	return;

									const Point& p0 = verts[mRef[0]];
									const Point& p1 = verts[mRef[1]];
									const Point& p2 = verts[mRef[2]];
									normal = ((p2-p1)^(p0-p1)).Normalize();
								}

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the triangle denormalized normal.
		 *	\param		verts	[in] the list of indexed vertices
		 *	\param		normal	[out] the computed normal
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline_	void			DenormalizedNormal(const Point* verts, Point& normal)				const
								{
									if(!verts)	return;

									const Point& p0 = verts[mRef[0]];
									const Point& p1 = verts[mRef[1]];
									const Point& p2 = verts[mRef[2]];
									normal = ((p2-p1)^(p0-p1));
								}

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the triangle center.
		 *	\param		verts	[in] the list of indexed vertices
		 *	\param		center	[out] the computed center
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline_	void			Center(const Point* verts, Point& center)							const
								{
									if(!verts)	return;

									const Point& p0 = verts[mRef[0]];
									const Point& p1 = verts[mRef[1]];
									const Point& p2 = verts[mRef[2]];
									center = (p0+p1+p2)*INV3;
								}

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the centered normal
		 *	\param		verts	[in] the list of indexed vertices
		 *	\param		normal	[out] the computed centered normal
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				void			CenteredNormal(const Point* verts, Point& normal)					const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes a random point within the triangle.
		 *	\param		verts	[in] the list of indexed vertices
		 *	\param		normal	[out] the computed centered normal
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				void			RandomPoint(const Point* verts, Point& random)						const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes backface culling.
		 *	\param		verts	[in] the list of indexed vertices
		 *	\param		source	[in] source point (in local space) from which culling must be computed
		 *	\return		true if the triangle is visible from the source point
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				bool			IsVisible(const Point* verts, const Point& source)					const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes backface culling.
		 *	\param		verts	[in] the list of indexed vertices
		 *	\param		source	[in] source point (in local space) from which culling must be computed
		 *	\return		true if the triangle is visible from the source point
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				bool			BackfaceCulling(const Point* verts, const Point& source)			const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the occlusion potential of the triangle.
		 *	\param		verts	[in] the list of indexed vertices
		 *	\param		source	[in] source point (in local space) from which occlusion potential must be computed
		 *	\return		the occlusion potential
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				float			ComputeOcclusionPotential(const Point* verts, const Point& view)	const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Replaces a vertex reference with another one.
		 *	\param		old_ref	[in] the vertex reference to replace
		 *	\param		new_ref	[in] the new vertex reference
		 *	\return		true if success, else false if the input vertex reference doesn't belong to the triangle
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				bool			ReplaceVertex(udword old_ref, udword new_ref);

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Checks whether the triangle is degenerate or not. A degenerate triangle has two common vertex references. This is a zero-area triangle.
		 *	\return		true if the triangle is degenerate
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				bool			IsDegenerate()														const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Checks whether the input vertex reference belongs to the triangle or not.
		 *	\param		ref		[in] the vertex reference to look for
		 *	\param		index	[out] the corresponding index in the triangle
		 *	\return		true if the triangle contains the vertex reference
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				bool			HasVertex(udword ref, udword* index=null)							const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Finds an edge in a tri, given two vertex references.
		 *	\param		vref0	[in] the edge's first vertex reference
		 *	\param		vref1	[in] the edge's second vertex reference
		 *	\return		the edge number between 0 and 2, or 0xff if input refs are wrong.
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				ubyte			FindEdge(udword vref0, udword vref1)								const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Gets the last reference given the first two.
		 *	\param		vref0	[in] the first vertex reference
		 *	\param		vref1	[in] the second vertex reference
		 *	\return		the last reference, or INVALID_ID if input refs are wrong.
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				udword			OppositeVertex(udword vref0, udword vref1)							const;
		inline_	udword			OppositeVertex(ubyte edgenb)										const	{ return mRef[2-edgenb];	}

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Gets the three sorted vertex references according to an edge number.
		 *	edgenb = 0	=> edge 0-1, returns references 0, 1, 2
		 *	edgenb = 1	=> edge 0-2, returns references 0, 2, 1
		 *	edgenb = 2	=> edge 1-2, returns references 1, 2, 0
		 *
		 *	\param		edgenb	[in] the edge number, 0, 1 or 2
		 *	\param		vref0	[out] the returned first vertex reference
		 *	\param		vref1	[out] the returned second vertex reference
		 *	\param		vref2	[out] the returned third vertex reference
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				void			GetVRefs(ubyte edgenb, udword& vref0, udword& vref1, udword& vref2)	const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the triangle's smallest edge length.
		 *	\param		verts	[in] the list of indexed vertices
		 *	\return		the smallest edge length
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				float			MinEdgeLength(const Point* verts)									const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the triangle's largest edge length.
		 *	\param		verts	[in] the list of indexed vertices
		 *	\return		the largest edge length
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				float			MaxEdgeLength(const Point* verts)									const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes a point on the triangle according to the stabbing information.
		 *	\param		verts		[in] the list of indexed vertices
		 *	\param		u,v			[in] point's barycentric coordinates
		 *	\param		pt			[out] point on triangle
		 *	\param		near_vtx	[out] index of nearest vertex (null if not needed)
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				void			ComputePoint(const Point* verts, float u, float v, Point& pt, udword* near_vtx=null)	const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the angle between two triangles.
		 *	\param		tri		[in] the other triangle
		 *	\param		verts	[in] the list of indexed vertices
		 *	\return		the angle in radians
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				float			Angle(const IndexedTriangle& tri, const Point* verts)				const;

		inline_	Plane			PlaneEquation(const Point* verts)									const	{ return Plane(verts[mRef[0]], verts[mRef[1]], verts[mRef[2]]);	}

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Checks a triangle is the same as another one.
		 *	\param		tri		[in] the other triangle
		 *	\return		true if same triangle
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				bool			Equals(const IndexedTriangle& tri)									const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the triangle's cube index
		 *	\param		verts	[in] vertex pool
		 *	\return		cube index
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				CubeIndex		ComputeCubeIndex(const Point* verts)								const;
	};

	ICE_COMPILE_TIME_ASSERT(sizeof(IndexedTriangle)==12);

	class ICEMATHS_API IndexedTriangle16 : public Allocateable
	{
		public:
		//! Constructor
		inline_					IndexedTriangle16()									{}
		//! Constructor
		inline_					IndexedTriangle16(uword r0, uword r1, uword r2)		{ mRef[0]=r0; mRef[1]=r1; mRef[2]=r2; }
		//! Copy constructor
		inline_					IndexedTriangle16(const IndexedTriangle16& triangle)
								{
									mRef[0] = triangle.mRef[0];
									mRef[1] = triangle.mRef[1];
									mRef[2] = triangle.mRef[2];
								}
		//! Destructor
		inline_					~IndexedTriangle16()								{}
		//! Vertex-references
				uword			mRef[3];

				void			Flip();
				float			Area(const Point* verts)									const;
				void			Center(const Point* verts, Point& center)					const;
				void			DenormalizedNormal(const Point* verts, Point& normal)		const;
				bool			BackfaceCulling(const Point* verts, const Point& source)	const;
				bool			IsDegenerate()												const;
		inline_	Plane			PlaneEquation(const Point* verts)							const	{ return Plane(verts[mRef[0]], verts[mRef[1]], verts[mRef[2]]);	}
	};
	ICE_COMPILE_TIME_ASSERT(sizeof(IndexedTriangle16)==6);

#endif // ICEINDEXEDTRIANGLE_H
