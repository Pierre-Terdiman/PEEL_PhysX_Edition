///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Contains a handy triangle class.
 *	\file		IceTriangle.h
 *	\author		Pierre Terdiman
 *	\date		January, 17, 2000
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Include Guard
#ifndef ICETRIANGLE_H
#define ICETRIANGLE_H

	// Forward declarations
	class Moment;

	// Partitioning values
	enum PartVal
	{
		TRI_MINUS_SPACE		= 0,			//!< Triangle is in the negative space
		TRI_PLUS_SPACE		= 1,			//!< Triangle is in the positive space
		TRI_INTERSECT		= 2,			//!< Triangle intersects plane
		TRI_ON_PLANE		= 3,			//!< Triangle and plane are coplanar

		TRI_FORCEDWORD		= 0x7fffffff
	};

	// A triangle class.
	class ICEMATHS_API Triangle : public Allocateable
	{
		public:
		//! Constructor
		inline_					Triangle()													{}
		//! Constructor
		inline_					Triangle(const Point& p0, const Point& p1, const Point& p2)	{ mVerts[0]=p0; mVerts[1]=p1; mVerts[2]=p2; }
		//! Copy constructor
		inline_					Triangle(const Triangle& triangle)
								{
									mVerts[0] = triangle.mVerts[0];
									mVerts[1] = triangle.mVerts[1];
									mVerts[2] = triangle.mVerts[2];
								}
		//! Constructor
		inline_					Triangle(const Point* verts)
								{
									mVerts[0] = verts[0];
									mVerts[1] = verts[1];
									mVerts[2] = verts[2];
								}
		//! Destructor
		inline_					~Triangle()													{}
		//! Vertices
				Point			mVerts[3];

		// Methods
				void			Flip();

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the triangle area.
		 *	\return		the area
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline_	float			Area()	const
								{
									const Point& p0 = mVerts[0];
									const Point& p1 = mVerts[1];
									const Point& p2 = mVerts[2];
									return ((p0 - p1)^(p0 - p2)).Magnitude() * 0.5f;
								}

				float			Perimeter()	const;
				float			Compacity()	const;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the triangle normal.
		 *	\param		normal	[out] the computed normal
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline_	void			Normal(Point& normal) const
								{
									const Point& p0 = mVerts[0];
									const Point& p1 = mVerts[1];
									const Point& p2 = mVerts[2];
									normal = ((p0 - p1)^(p0 - p2)).Normalize();
								}

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the triangle denormalized normal.
		 *	\param		normal	[out] the computed normal
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline_	void			DenormalizedNormal(Point& normal) const
								{
									const Point& p0 = mVerts[0];
									const Point& p1 = mVerts[1];
									const Point& p2 = mVerts[2];
									normal = ((p0 - p1)^(p0 - p2));
								}

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/**
		 *	Computes the triangle center.
		 *	\param		center	[out] the computed center
		 */
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		inline_	void			Center(Point& center) const
								{
									const Point& p0 = mVerts[0];
									const Point& p1 = mVerts[1];
									const Point& p2 = mVerts[2];
									center = (p0 + p1 + p2)*INV3;
								}

		inline_	Plane			PlaneEquation() const	{ return Plane(mVerts[0], mVerts[1], mVerts[2]);	}

				PartVal			TestAgainstPlane(const Plane& plane, float epsilon)					const;
//				float			Distance(Point& cp, Point& cq, Tri& tri);
				void			ComputeMoment(Moment& m)											const;
				float			MinEdgeLength()														const;
				float			MaxEdgeLength()														const;
				void			ComputePoint(float u, float v, Point& pt, udword* near_vtx=null)	const;
				void			Inflate(float fat_coeff, bool constant_border);
	};

#endif // ICETRIANGLE_H
